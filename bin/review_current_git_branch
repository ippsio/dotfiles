#!/bin/bash

[ ! $(git rev-parse --is-inside-work-tree 2>/dev/null) ] && echo "Not a git repository." && return
CURRENT_BRANCH=$(git branch --contains| tr -d "* ")

# true: PRから自動的にマージ先ブランチを取得して欲しい。false:マージ先ブランチを自分で選択したい。
SELECT_BRANCH=false

arg_verbose=$(for arg in "$@"; do [[ "${arg}" =~ "--verbose" ]] && echo "${arg}"; done;)
_fg() { printf "\e[38;5;%dm" "$1"; }
_bg() { printf "\e[48;5;%dm" "$1"; }
_verbose() { [[ ! -z "${arg_verbose}" ]] && return 0 || return 1; }
_echo() { ARG_COLOR=$2; printf "\e[m%s" "${ARG_COLOR}"; echo -n "$1"; printf "\e[m\n"; }
_echon() { ARG_COLOR=$2; printf "\e[m%s" "${ARG_COLOR}"; echo -n "$1"; printf "\e[m"; }

_mergebase() {
  local mergebase
  if "${SELECT_BRANCH}"; then
    merge_base_branch=$(fzf_git_branch)
  else # github apiのauthorizationトークンを ~/.config/hub ファイルから読む。
    local AUTHZ_TOKEN=$(cat ~/.config/hub| grep "oauth_token:"| awk '{ print $2 }')
    # gitのリポジトリ名を取得。
    local REPO=$(git remote get-url origin 2> /dev/null| egrep -o "([a-zA-Z0-9+-]+)\/([a-zA-Z0-9+-]+)")
    # 現在のブランチを検索条件に、PR番号を取得。
    local PR_NO=$(curl -X GET -s -H "Authorization: token ${AUTHZ_TOKEN}" "https://api.github.com/search/issues?q=type:pr%20repo:${REPO}%20head:${CURRENT_BRANCH}"| jq -r '.items[] | .number')
    if [[ ! -z "${PR_NO}" ]]; then
      # PRの情報を取得し、現在のブランチとマージ先ブランチを取得。
      local PR_INFO=$(curl -s -H "Authorization: token ${AUTHZ_TOKEN}" "https://api.github.com/repos/${REPO}/pulls/${PR_NO}"| jq -r '.head.ref, .base.ref')
      if [[ $(echo -e "$PR_INFO"| wc -l| tr -d ' ') -eq 2 ]]; then
        # PRの情報からマージ先ブランチを取得（成功）。
        merge_base_branch=$(echo -e "${PR_INFO}"| tail -n 1)
      else
        merge_base_branch=$(fzf_git_branch)
      fi
    else
      merge_base_branch=$(fzf_git_branch)
    fi
  fi
  echo "${merge_base_branch}"
}

MERGE_BASE_BRANCH=$(_mergebase)
echo $MERGE_BASE_BRANCH
MERGE_BASE_LONG_HASH="$(git merge-base ${MERGE_BASE_BRANCH} HEAD)"
MERGE_BASE_HASH=$(git rev-parse --short "${MERGE_BASE_LONG_HASH}")

_COLOR_LABEL="$(_fg 187)$(_bg 100)"
_COLOR_COMMAND="$(_fg 245)$(_bg 234)"
while true; do
  clear
  # branchs
  _echon "[branches]" "${_COLOR_LABEL}"
  _echon " '"
  _echon "${MERGE_BASE_BRANCH}" $(_fg 220)$(_bg 237)
  _echon "'<='"
  _echon "${CURRENT_BRANCH}" $(_fg 220)$(_bg 237)
  _echo  "'"

  # merge-base
  _echon "[merge-base-hash]" "${_COLOR_LABEL}"
  _verbose && _echo " git rev-parse --short \$(git merge-base ${MERGE_BASE_BRANCH} HEAD)" "${_COLOR_COMMAND}"
  _echo " ${MERGE_BASE_HASH}"

  # git log
  # (total commit count)
  _CMD="git --no-pager log --oneline ${MERGE_BASE_HASH}...HEAD| wc -l| tr -d ' '"
  _verbose && _echo " ${_CMD}" "${_COLOR_COMMAND}"
  _TOTAL_COMMITS=$(eval "${_CMD}")

  HASH="%C($(git config --get color.diff.commit))%h%Creset"
  COMMIT_DATE="%cd"
  AUTHOR="%C(187 17)%an%Creset"
  SUBJECT="%s"
  COMMITS_COUNT_LAST=3

  _echon "[git log]" "${_COLOR_LABEL}" && echo " (${_TOTAL_COMMITS} commits in total.)"
  _CMD="git --no-pager log --oneline ${MERGE_BASE_HASH}...HEAD --reverse --oneline -${COMMITS_COUNT_LAST}"
  _CMD+=" --date=format-local:'%Y/%m/%d %H:%M'"
  _CMD+=" --pretty=format:\" ${HASH} ${COMMIT_DATE} ${AUTHOR} ${SUBJECT}\""
  _CMD+=" --abbrev-commit"
  _verbose && _echo " ${_CMD}" "${_COLOR_COMMAND}"
  eval "${_CMD}"; echo

  # git diff --stat
  _echo "[git diff --stat]" "${_COLOR_LABEL}"
  _STAT_GRAPH_WIDTH_COLS=$(( $(tput cols) / 4 ))
  _CMD="git diff --stat-graph-width=${_STAT_GRAPH_WIDTH_COLS} ${MERGE_BASE_HASH}"
  _verbose && _echo " ${_CMD}" "${_COLOR_COMMAND}"
  eval "${_CMD}"

  # command
  list=()
  list+=("1, edit (neovim)          - (fzf_git_diff \"${MERGE_BASE_HASH}\" \"enter\")")
  list+=("2, show tig               - (tig ${MERGE_BASE_HASH}...HEAD)")
  list+=("3, show git diff          - (git diff ${MERGE_BASE_HASH} | nvim -R)")
  list+=("4, show git diff(compact) - (git diff ${MERGE_BASE_HASH} --unified=0| nvim -R)")
  list+=("5, pull git branch        - (git fetch origin --prune; git merge)")
  REPLY=$(for element in "${list[@]}"; do printf "${element}\n"; done \
    | fzf --info=hidden --height=8 --prompt="COMMAND> " --bind "j:down" --bind "k:up" \
    | awk -F ',' '{ print $1 }')
  case "${REPLY}" in
    1) fzf_git_diff "${MERGE_BASE_HASH}" "enter" ;;
    2) tig ${MERGE_BASE_HASH}...HEAD ;;
    3) git diff ${MERGE_BASE_HASH} | nvim -R ;;
    4) git diff ${MERGE_BASE_HASH} --unified=0 | nvim -R ;;
    5) set -x; git fetch origin --prune ; git merge ; set +x; echo "enter to continue."; read ;;
    *) break
  esac
done
