#!/bin/bash
# exit when not a git repository.
! $(is_git_repository) && echo "Not a git repository." && exit 1

arg_verbose=$(for arg in "$@"; do [[ "${arg}" =~ "--verbose" ]] && echo "${arg}"; done;)
args=(); for arg in "$@"; do [[ "${arg}" =~ "--verbose" ]] && arg_verbose="${arg}" || args=("${args[@]}" "${arg}"); done

commit1=${args[0]}

_fg() { printf "\e[38;5;%dm" "$1"; }
_bg() { printf "\e[48;5;%dm" "$1"; }
_verbose() { [[ ! -z "${arg_verbose}" ]] && return 0 || return 1; }
_COLOR_COMMAND="$(_fg 245)$(_bg 234)"
_echo() {  ARG_COLOR=$2; printf "\e[m%s" "${ARG_COLOR}"; echo -n "$1"; printf "\e[m"; echo; }
_echo2() { printf "\e[m%s" "$(_fg 220)$(_bg 237)"; echo -n "$1"; printf "\e[m"; echo; }
_echo3() { printf "\e[m%s" "$(_fg 245)$(_bg 234)"; echo -n "$1"; printf "\e[m"; echo; }
_echon() { ARG_COLOR=$2; printf "\e[m%s" "${ARG_COLOR}"; echo -n "$1"; printf "\e[m"; }
_echon2() { printf "\e[m%s" "$(_fg 187)$(_bg 100)"; echo -n "$1"; printf "\e[m"; }

CURRENT_BRANCH=$(current_git_branch)
MERGE_BASE_INFO=$(git_get_merge_base_info "${CURRENT_BRANCH}" "${commit1}")
MERGE_BASE_BRANCH=$(echo "${MERGE_BASE_INFO}"| grep "MERGE_BASE_BRANCH="| awk -F '=' '{ print $2 }'| sed -e 's#^origin/##'| sed -e 's/ *//g')
if [[ "${MERGE_BASE_BRANCH}" == "" ]]; then
  echo "MERGE_BASE_BRANCH empty. Bye"
  exit 1
fi
MERGE_BASE_BRANCH=origin/${MERGE_BASE_BRANCH}
MERGE_BASE_LONG_HASH="$(git merge-base ${MERGE_BASE_BRANCH} HEAD)"
MERGE_BASE_HASH=$(git rev-parse --short "${MERGE_BASE_LONG_HASH}")
PR_NO=$(echo "${MERGE_BASE_INFO}"| grep "PR_NO="| awk -F '=' '{ print $2 }')

GIT_LOG_HEAD_3_CMD="(git --no-pager log --oneline --full-history --simplify-merges ${MERGE_BASE_HASH}.. --oneline"\
" --date=format-local:'%Y/%m/%d %H:%M'"\
" --pretty=format:\" %C($(git config --get color.diff.commit))%h%Creset %cd %C(187 17)%an%Creset %s\""\
" --abbrev-commit --color=always; echo)| head -3"\

GIT_COMMIT_COUNT_CMD="git --no-pager log --oneline ${MERGE_BASE_HASH}...HEAD| wc -l| tr -d ' '"
GIT_LOG_1_MERGE_BASE="git log --oneline ${MERGE_BASE_HASH} --oneline -1 --date=format-local:'%Y/%m/%d %H:%M' --pretty=format:'%h %cd %an %s' --abbrev-commit"

GIT_DIFF_STAT_CMD="git diff --color=always --stat-graph-width=$(( $(tput cols) / 1 )) ${MERGE_BASE_HASH}"

COMMANDS=$(cat << EOF
1, edit (neovim)     - 	git_diff_fzf "${MERGE_BASE_BRANCH}"
2, git log           - 	git_log_fzf  "${MERGE_BASE_BRANCH}.."
3, tig               - 	tig          "${MERGE_BASE_BRANCH}.."
4, git diff          - 	git diff     "${MERGE_BASE_BRANCH}..." | nvim -R
5, git diff(compact) - 	git diff     "${MERGE_BASE_BRANCH}..." --unified=0| nvim -R
6, pull git branch   - 	set -x; git fetch origin --prune; git merge --ff; set +x; read
7, open pull request - 	open https://github.com/$(git_reponame_get)/pull/${PR_NO}
8, show pull request - 	git_pr_fzf "${CURRENT_BRANCH}"
EOF
)

while true; do
  clear
  _echon2 "[merge_base_branch_info]"; echo
  echo -e "${MERGE_BASE_INFO}"| awk -F '=' '{ print " " $1 "=[" $2 "]" }'

  # branchs
  _echon2 "[branches]"
  _echo2 "${MERGE_BASE_BRANCH}<=${CURRENT_BRANCH}"

  # merge-base
  _echon2 "[merge-base]"
  _verbose && _echo3 "${GIT_LOG_1_MERGE_BASE}"
  _echo2 "$(eval ${GIT_LOG_1_MERGE_BASE})"

  # (total commit count)
  _echon2 "[git log]"
  _verbose && _echo3 " ${GIT_COMMIT_COUNT_CMD}"
  _echo2 "$(eval ${GIT_COMMIT_COUNT_CMD}) commits."

  # recent 3 commits.
  _verbose && _echo3 " ${GIT_LOG_HEAD_3_CMD}"
  eval "${GIT_LOG_HEAD_3_CMD}"| sed -r 's/^/#AWK_DELIMITTER#/'| cat -n| sed -r 's/^ +//'| sed -r 's/\t//g'| awk -F '#AWK_DELIMITTER#' '{ printf "%+2s " , $1 } { print $2 }'

  # git diff --stat
  _echon2 "[git diff --stat]"; echo
  _verbose && _echo3 " ${GIT_DIFF_STAT_CMD}"
  GIT_DIFF_STAT=$(eval "${GIT_DIFF_STAT_CMD}")
  GIT_DIFF_STAT_CNT=$(echo "${GIT_DIFF_STAT}"| wc -l| tr -d ' ')
  echo "${GIT_DIFF_STAT}"| sed -r 's/^/#AWK_DELIMITTER#/'| cat -n| sed -r 's/^ +//'| sed -r 's/\t//g'| awk -F '#AWK_DELIMITTER#' '{ printf "%+'${#GIT_DIFF_STAT_CNT}'s " , $1 } { print $2 }'| tac| tail -n +2| tac

  # current directory
  _echon2 "[pwd]"; _echo2 " $(pwd| sed -e "s#$HOME#~#")"

  # command
  ANS=$(echo "${COMMANDS}"| fzf --disabled --info=hidden --height=11 --prompt="COMMAND> " --bind "j:down" --bind "k:up" | awk -F "\t" '{ print $2 }')
  [[ -z ${ANS} ]] && exit || eval ${ANS}
done
