#!/bin/bash

# git_grep_fzf_vim
# git grep earch + fzf filter +  edit with vim .
#ARGS=${1:-.}
#GIT_GREP_CMD="git grep --line-number --color=always --extended-regexp \"${ARGS}\""

PARAMS=""
while (( $# > 0 )); do
  case $1 in
    -B | -A | -C)
      if [[ -z "$2" ]] || [[ "$2" =~ ^-+ ]]; then
        echo "'${1}' requires an argument." 1>&2
        exit 1
      else
        PARAMS="${PARAMS}$1 $2 "
        shift
      fi
      ;;
    *)
      PARAMS="${PARAMS}\"$1\" "
      ;;
  esac
  shift
done
GIT_GREP_CMD="git grep --null --line-number --color=always --extended-regexp ${PARAMS}"
FZF_PROMPT="$(basename $0)"
FZF_HEADER="enter:nvim"
FZF_REZULT=$(eval "${GIT_GREP_CMD}" \
  | perl -pe "s/\x0/\t/g" \
  | grep -v '\-\-' \
  | cat -n \
  | fzf -m \
    --ansi \
    --info=inline \
    --delimiter='	' \
    --tabstop=2 \
    --prompt="${FZF_PROMPT} > " \
    --header="${GIT_GREP_CMD}" \
    --bind "ctrl-c:print-query" \
    --bind "ctrl-p:toggle-preview" \
    --bind "ctrl-/:toggle-preview" \
    --bind="enter:execute(nvim {2} +{3} < /dev/tty > /dev/tty)" \
    --preview-window"=bottom:65%"\
    --preview='
      # 原則、検索ヒットした行の15行前から表示。
      from=$(expr {3} - 15);
      [[ ${from} -lt 1 ]] && from=1;
      echo "$(realpath {2}| home_as_tilde)";
      echo "---";

      # このawkスクリプトは、ファイル名部分(下記例ではsome_dir/some-file.rb) を削除しています。
      # ```
      # awk "{ printf \"%s%s\n\", substr(\$0, 0, index(\$0, \" \") - 1), substr(\$0, index(\$0, \" (\")) }"\
      # ```
      # ここで消したいファイル名部分は、awk的には$2 です。
      # 単純にawk '{ $2=""; print $0 }' とした場合、コミッターの名前部分等に半角スペースの崩れが発生し、
      # 体裁が悪化しました。
      # 期待する例）
      # > b2bef2bc7b4 some_dir/some-file.rb (William Henry Gates 2018-09-21 19:03:22 +0900  27)     [*1..3].each do |word|
      # > b4fecr54i00 some_dir/some-file.rb (Mark Gonzales       2018-09-21 19:03:22 +0900  28)       puts word
      # > 505aff35276 some_dir/some-file.rb (Peat Sampras        2018-09-21 19:03:22 +0900  29)     end
      #
      # 体裁が崩れた例）
      # > b2bef2bc7b4 some_dir/some-file.rb (William Henry Gates 2018-09-21 19:03:22 +0900  27)     [*1..3].each do |word|
      # > b4fecr54i00 some_dir/some-file.rb (Mark Gonzales 2018-09-21 19:03:22 +0900  28)       puts word
      # > 505aff35276 some_dir/some-file.rb (Peat Sampras 2018-09-21 19:03:22 +0900  29)     end
      #
      # そこでsubstr を用いてファイル名以外の部分のみをprintするように実装しました。
      git blame --show-name {2} \
        | awk "{ printf \"%s%s\n\", substr(\$0, 0, index(\$0, \" \") - 1), substr(\$0, index(\$0, \" (\")) }"\
        | awk "{
        # コミットハッシュに色付けする。色付けにはコミットハッシュの先頭2バイト(00〜FF) を用いる。
        H1 = toupper(substr(\$1, 1, 1))
        H2 = toupper(substr(\$1, 2, 1))

        # 16進数と10進数の変換表。gawkには進数変換用の組み込み関数があるらしいです。いいなぁ。
        H[\"0\"] =  0; H[\"1\"] =  1; H[\"2\"] =  2; H[\"3\"] =  3; H[\"4\"] =  4; H[\"5\"] =  5; H[\"6\"] = 6; H[\"7\"] = 7; H[\"8\"] = 8; H[\"9\"] = 9;
        H[\"A\"] = 10; H[\"B\"] = 11; H[\"C\"] = 12; H[\"D\"] = 13; H[\"E\"] = 14; H[\"F\"] = 15;

        # 16進数の10進変換
        COLOR = H[H1] * 16 + H[H2]

        # 色付きのコミットハッシュ
        printf(\"\033[38;5;%dm%s\033[0m\", COLOR, \$1);

        # 入力された文字列($0)からコミットハッシュ部分だけを削除。するとこれ以降の$0にはコミットハッシュが含まれなくなります。
        sub(/^[0-9a-fA-F]*/, \"\", \$0);

        # 残りの情報を出力。
        printf \"%s\n\", \$0
      }"\
      | bat \
        --color=always \
        --style=numbers,header \
        --line-range ${from}: \
        --highlight-line {3}
      ')

if [[ ! -z "${FZF_REZULT}" ]]; then
  echo "QUERY> ${FZF_REZULT}"
fi

